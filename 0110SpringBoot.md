# Spring Boot 17-20

# CRUD와 SQL쿼리

> **CRUD**는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다.
> 

일단 application.properties파일을 아래와 같이 변경해주었다.

```tsx
#h2 DB 웹 콘솔 접근 허용
spring.h2.console.enabled=true
#JPA 로깅 설정
#디버그 레벨로 쿼리 출력
logging.level.org.hibernate.SQL=DEBUG
#이쁘게 보여주기
spring.jpa.properties.hibernate.format_sql=true
#파라미터 보여주기
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

#DB URL고정 설정
#고정 url설정
spring.datasource.url= jdbc:h2:mem:testdb
#유니크 URL생성X
spring.datasource.generate-unique-name=false

spring.jpa.defer-datasource-initialization=true
```

→ 저번의 코드에서 아래의 두 줄을 지워야 새로운 article을 생성할 때 오류가 발생하지 않았다. 

```tsx
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```

## CREATE

기존 테이블에 3개의 데이터(ID가 각각 1,2,3)가 들어가 있어서 새로운 ARTICLE을 생성할 때, 기존에는 ID가 1부터 시작되어 겹치게 된다. 이를 고치기 위해 ENTITY인 Article.java에서 `@GeneratedValue` 부분을 

`@GeneratedValue(strategy = GenerationType.*IDENTITY*)` 이렇게 수정하였다.

> **자동 생성 전략(4 가지)**
> 
> 
> **IDENTITY** : 기본 키 생성을 DB에 위임, 즉 ID값을 null로 하면 DB가 알아서 AUTO_INCREMENT해준다.
> 
> SEQUENCE : 유일한 값을 순서대로 생성하는 특별한 DB오브젝트이다.
> 
> TABLE : 키 생성 전용 테이블을 하나 만들어서  DB 시퀀스를 흉내내는 전략
> 
> AUTO : 기본값
> 

```sql
create table article (
       id bigint generated by default as identity,
        content varchar(255),
        title varchar(255),
        primary key (id)
    )
```

## INSERT

새로운 ARTICLE을 추가하였을 때 CONSOLE에서 아래와 같은 알림을 준다. 이는  application.properties에서 로깅 설정을 해놓았기 때문이다.

```sql
		insert 
    into
        article
        (id, content, title) 
    values
        (null, ?, ?)
2022-01-10 17:54:32.597 TRACE 15308 --- [nio-8080-exec-4] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [4444]
2022-01-10 17:54:32.598 TRACE 15308 --- [nio-8080-exec-4] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [VARCHAR] - [라라라라]
2022-01-10 17:54:32.603  INFO 15308 --- [nio-8080-exec-4] c.e.f.controller.ArticleController       : Article(id=4, title=라라라라, content=4444)
2022-01-10 17:54:32.610  INFO 15308 --- [nio-8080-exec-5] c.e.f.controller.ArticleController       : id = 4
```

![새로운 레코드 추가 PNG](https://user-images.githubusercontent.com/77094833/148784110-1647499f-fae7-42c0-9765-f75e9151decd.png)

## UPDATE

ARTICLE의 정보를 수정하였을 때 아래와 같은 알림을 준다. 

```sql
		update
        article 
    set
        content=?,
        title=? 
    where
        id=?
2022-01-10 17:57:26.110 TRACE 15308 --- [io-8080-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [UPDATE4444]
2022-01-10 17:57:26.110 TRACE 15308 --- [io-8080-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [VARCHAR] - [라라라라UPDATE]
2022-01-10 17:57:26.110 TRACE 15308 --- [io-8080-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [3] as [BIGINT] - [4]
2022-01-10 17:57:26.115  INFO 15308 --- [nio-8080-exec-1] c.e.f.controller.ArticleController       : id = 4
```

![UPDATE PNG](https://user-images.githubusercontent.com/77094833/148784153-38c2ad1b-0035-4ddc-83aa-a019ff63346c.png)

## DELETE

데이터를 삭제했을 때 아래와 같은 알림이 뜬다.

```sql
2022-01-10 17:59:46.440 TRACE 15308 --- [nio-8080-exec-4] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [4]
2022-01-10 17:59:46.441  INFO 15308 --- [nio-8080-exec-4] c.e.f.controller.ArticleController       : Article(id=4, title=라라라라UPDATE, content=UPDATE4444)
2022-01-10 17:59:46.444 DEBUG 15308 --- [nio-8080-exec-4] org.hibernate.SQL                        : 
	  delete 
    from
        article 
    where
        id=?
```

![DELETE PNG](https://user-images.githubusercontent.com/77094833/148784179-327c8a75-4fe0-4a0b-be58-84adde715b99.png)

# RestAPI와 JSON

JSON파일은 [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com/) 

API테스트는 Talend API Tester(크롬 확장 프로그램)에서 진행

## GET

![get요청 성공 200 PNG](https://user-images.githubusercontent.com/77094833/148784210-30c1c556-4adf-4d88-9353-a69cb8c140dc.png)

GET요청 성공 → 200

![get요청 실패 404 PNG](https://user-images.githubusercontent.com/77094833/148784236-8a309832-767b-4010-8024-3b119544914d.png)

GET요청 실패 → 404

## POST

![post요청 성공201 PNG](https://user-images.githubusercontent.com/77094833/148784249-908b976f-74c3-4649-9d6f-ae173ac51209.png)

POST요청 성공 → 201

![post요청 실패 500 PNG](https://user-images.githubusercontent.com/77094833/148784270-5b7127ad-73b1-4ee4-93ce-a3ab4c2cdfcd.png)

POST요청 실패 → 500

## PATCH

![patch성공 200 PNG](https://user-images.githubusercontent.com/77094833/148784298-f48939ea-6b6a-46b1-b8fe-27eeea02aef8.png)

PATCH(UPDATE) 성공 → 200

## DELETE

![delete 성공 200 PNG](https://user-images.githubusercontent.com/77094833/148784322-39f5c978-0c92-41bc-882a-754a362cf804.png)

DELETE성공 → 200

# HTTP와 RestController

![서버와 클라이언트의 소통 구조 PNG](https://user-images.githubusercontent.com/77094833/148784362-1629a477-347b-4454-99e9-e56fa70a63b7.png)

![http PNG](https://user-images.githubusercontent.com/77094833/148784383-b123ba53-8f79-4f2f-96e3-ebb8f43c6446.png)

## GET

```java
@GetMapping("/api/articles")
    public List<Article> index(){
        return articleRepository.findAll();
    }
@GetMapping("/api/articles/{id}")
    public Article index(@PathVariable Long id){
        return articleRepository.findById(id).orElse(null);
    }
```

→ 해당 API에 요청했을 경우, 아래와 같이 JSON을 RETURN한다.

![GET JSON PNG](https://user-images.githubusercontent.com/77094833/148784415-db5e3d03-d415-4b68-a0a6-90c260704ecc.png)

## POST

```java
@PostMapping ("/api/articles")
    public Article create(@RequestBody ArticleForm dto){
        Article article = dto.toEntity();
        return articleRepository.save(article);
    }
```

→ 해당 API에 요청했을 경우, 아래와 같이 새로 데이터가 추가되며 JSON을 RETURN한다.

![POST JSON PNG](https://user-images.githubusercontent.com/77094833/148784435-491dbf0d-a5c0-48d2-a583-b3db6165cf58.png)

## PATCH

```java
@PatchMapping ("/api/articles/{id}")
    public ResponseEntity<Article> update(@PathVariable Long id,
                                          @RequestBody ArticleForm dto){
        //1 : 수정용 엔티티 생성
        Article article = dto.toEntity();
        log.info("id:{}, article:{}",id,article.toString());

        //2 : 대상 엔티티를 조회
        Article target=articleRepository.findById(id).orElse(null);

        //3 : 잘못된 요청 처리(대상이 없거나, id가 다른 경우)
        if(target==null || id!=article.getId()){
            //400, 잘못된 요청 응답!
            log.info("잘못된 요청! id:{}, article:{}", id, article.toString());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        //4 : 업데이트 및 정상 응답(200)
        target.patch(article); //내용이 원래 있다면 넣어준다.
        Article updated=articleRepository.save(target); //넣어준 후에 변경
        return ResponseEntity.status(HttpStatus.OK).body(updated);
    }
```

→ 해당 API를 요청하고 아래와 같이 변경하고 싶은 정보를 입력하면 UPDATE되며 JSON을 RETURN한다.

![PATCH JSON PNG](https://user-images.githubusercontent.com/77094833/148784462-25e3e1e0-5b6f-4fe1-b6e5-33183828da53.png)

## DELETE

```java
@DeleteMapping("/api/articles/{id}")
    public ResponseEntity<Article> delete(@PathVariable Long id){
        //대상 찾기
        Article target=articleRepository.findById(id).orElse(null);
        //잘못된 요청 처리(데이터가 없는 경우)
        if(target==null){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        //대상 삭제
        articleRepository.delete(target);
        //데이터 변환
        return ResponseEntity.status(HttpStatus.OK).body(null);
    }
```

→ 해당 API를 요청할 경우, 데이터가 DB에서 삭제되고 상태(STATUS)만을 RETURN한다.

![DELETE JSON PNG](https://user-images.githubusercontent.com/77094833/148784480-3c5d3023-25b2-47e7-ab08-5c19b2e021bf.png)
