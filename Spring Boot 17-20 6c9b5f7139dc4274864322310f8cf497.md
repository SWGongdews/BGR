# Spring Boot 17-20

# CRUD와 SQL쿼리

> **CRUD**는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다.
> 

일단 application.properties파일을 아래와 같이 변경해주었다.

```tsx
#h2 DB 웹 콘솔 접근 허용
spring.h2.console.enabled=true
#JPA 로깅 설정
#디버그 레벨로 쿼리 출력
logging.level.org.hibernate.SQL=DEBUG
#이쁘게 보여주기
spring.jpa.properties.hibernate.format_sql=true
#파라미터 보여주기
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

#DB URL고정 설정
#고정 url설정
spring.datasource.url= jdbc:h2:mem:testdb
#유니크 URL생성X
spring.datasource.generate-unique-name=false

spring.jpa.defer-datasource-initialization=true
```

→ 저번의 코드에서 아래의 두 줄을 지워야 새로운 article을 생성할 때 오류가 발생하지 않았다. 

```tsx
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```

## CREATE

기존 테이블에 3개의 데이터(ID가 각각 1,2,3)가 들어가 있어서 새로운 ARTICLE을 생성할 때, 기존에는 ID가 1부터 시작되어 겹치게 된다. 이를 고치기 위해 ENTITY인 Article.java에서 `@GeneratedValue` 부분을 

`@GeneratedValue(strategy = GenerationType.*IDENTITY*)` 이렇게 수정하였다.

> **자동 생성 전략(4 가지)**
> 
> 
> **IDENTITY** : 기본 키 생성을 DB에 위임, 즉 ID값을 null로 하면 DB가 알아서 AUTO_INCREMENT해준다.
> 
> SEQUENCE : 유일한 값을 순서대로 생성하는 특별한 DB오브젝트이다.
> 
> TABLE : 키 생성 전용 테이블을 하나 만들어서  DB 시퀀스를 흉내내는 전략
> 
> AUTO : 기본값
> 

```sql
create table article (
       id bigint generated by default as identity,
        content varchar(255),
        title varchar(255),
        primary key (id)
    )
```

## INSERT

새로운 ARTICLE을 추가하였을 때 CONSOLE에서 아래와 같은 알림을 준다. 이는  application.properties에서 로깅 설정을 해놓았기 때문이다.

```sql
		insert 
    into
        article
        (id, content, title) 
    values
        (null, ?, ?)
2022-01-10 17:54:32.597 TRACE 15308 --- [nio-8080-exec-4] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [4444]
2022-01-10 17:54:32.598 TRACE 15308 --- [nio-8080-exec-4] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [VARCHAR] - [라라라라]
2022-01-10 17:54:32.603  INFO 15308 --- [nio-8080-exec-4] c.e.f.controller.ArticleController       : Article(id=4, title=라라라라, content=4444)
2022-01-10 17:54:32.610  INFO 15308 --- [nio-8080-exec-5] c.e.f.controller.ArticleController       : id = 4
```

![새로운 레코드 추가.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/%EC%83%88%EB%A1%9C%EC%9A%B4_%EB%A0%88%EC%BD%94%EB%93%9C_%EC%B6%94%EA%B0%80.png)

## UPDATE

ARTICLE의 정보를 수정하였을 때 아래와 같은 알림을 준다. 

```sql
		update
        article 
    set
        content=?,
        title=? 
    where
        id=?
2022-01-10 17:57:26.110 TRACE 15308 --- [io-8080-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [UPDATE4444]
2022-01-10 17:57:26.110 TRACE 15308 --- [io-8080-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [VARCHAR] - [라라라라UPDATE]
2022-01-10 17:57:26.110 TRACE 15308 --- [io-8080-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [3] as [BIGINT] - [4]
2022-01-10 17:57:26.115  INFO 15308 --- [nio-8080-exec-1] c.e.f.controller.ArticleController       : id = 4
```

![UPDATE.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/UPDATE.png)

## DELETE

데이터를 삭제했을 때 아래와 같은 알림이 뜬다.

```sql
2022-01-10 17:59:46.440 TRACE 15308 --- [nio-8080-exec-4] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [4]
2022-01-10 17:59:46.441  INFO 15308 --- [nio-8080-exec-4] c.e.f.controller.ArticleController       : Article(id=4, title=라라라라UPDATE, content=UPDATE4444)
2022-01-10 17:59:46.444 DEBUG 15308 --- [nio-8080-exec-4] org.hibernate.SQL                        : 
	  delete 
    from
        article 
    where
        id=?
```

![DELETE.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/DELETE.png)

# RestAPI와 JSON

JSON파일은 [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com/) 

API테스트는 Talend API Tester(크롬 확장 프로그램)에서 진행

## GET

![GET요청 성공 → 200](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/get%EC%9A%94%EC%B2%AD_%EC%84%B1%EA%B3%B5_200.png)

GET요청 성공 → 200

![GET요청 실패 → 404](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/get%EC%9A%94%EC%B2%AD_%EC%8B%A4%ED%8C%A8_404.png)

GET요청 실패 → 404

## POST

![POST요청 성공 → 201](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/post%EC%9A%94%EC%B2%AD_%EC%84%B1%EA%B3%B5201.png)

POST요청 성공 → 201

![POST요청 실패 → 500](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/post%EC%9A%94%EC%B2%AD_%EC%8B%A4%ED%8C%A8_500.png)

POST요청 실패 → 500

## PATCH

![PATCH(UPDATE) 성공 → 200](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/patch%EC%84%B1%EA%B3%B5_200.png)

PATCH(UPDATE) 성공 → 200

## DELETE

![DELETE성공 → 200](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/delete_%EC%84%B1%EA%B3%B5_200.png)

DELETE성공 → 200

# HTTP와 RestController

![서버와 클라이언트의 소통 구조.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/%EC%84%9C%EB%B2%84%EC%99%80_%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98_%EC%86%8C%ED%86%B5_%EA%B5%AC%EC%A1%B0.png)

![http.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/http.png)

## GET

```java
@GetMapping("/api/articles")
    public List<Article> index(){
        return articleRepository.findAll();
    }
@GetMapping("/api/articles/{id}")
    public Article index(@PathVariable Long id){
        return articleRepository.findById(id).orElse(null);
    }
```

→ 해당 API에 요청했을 경우, 아래와 같이 JSON을 RETURN한다.

![GET JSON.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/GET_JSON.png)

## POST

```java
@PostMapping ("/api/articles")
    public Article create(@RequestBody ArticleForm dto){
        Article article = dto.toEntity();
        return articleRepository.save(article);
    }
```

→ 해당 API에 요청했을 경우, 아래와 같이 새로 데이터가 추가되며 JSON을 RETURN한다.

![POST JSON.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/POST_JSON.png)

## PATCH

```java
@PatchMapping ("/api/articles/{id}")
    public ResponseEntity<Article> update(@PathVariable Long id,
                                          @RequestBody ArticleForm dto){
        //1 : 수정용 엔티티 생성
        Article article = dto.toEntity();
        log.info("id:{}, article:{}",id,article.toString());

        //2 : 대상 엔티티를 조회
        Article target=articleRepository.findById(id).orElse(null);

        //3 : 잘못된 요청 처리(대상이 없거나, id가 다른 경우)
        if(target==null || id!=article.getId()){
            //400, 잘못된 요청 응답!
            log.info("잘못된 요청! id:{}, article:{}", id, article.toString());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        //4 : 업데이트 및 정상 응답(200)
        target.patch(article); //내용이 원래 있다면 넣어준다.
        Article updated=articleRepository.save(target); //넣어준 후에 변경
        return ResponseEntity.status(HttpStatus.OK).body(updated);
    }
```

→ 해당 API를 요청하고 아래와 같이 변경하고 싶은 정보를 입력하면 UPDATE되며 JSON을 RETURN한다.

![PATCH JSON.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/PATCH_JSON.png)

## DELETE

```java
@DeleteMapping("/api/articles/{id}")
    public ResponseEntity<Article> delete(@PathVariable Long id){
        //대상 찾기
        Article target=articleRepository.findById(id).orElse(null);
        //잘못된 요청 처리(데이터가 없는 경우)
        if(target==null){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        //대상 삭제
        articleRepository.delete(target);
        //데이터 변환
        return ResponseEntity.status(HttpStatus.OK).body(null);
    }
```

→ 해당 API를 요청할 경우, 데이터가 DB에서 삭제되고 상태(STATUS)만을 RETURN한다.

![DELETE JSON.PNG](Spring%20Boot%2017-20%206c9b5f7139dc4274864322310f8cf497/DELETE_JSON.png)